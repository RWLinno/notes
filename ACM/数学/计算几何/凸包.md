凸包：Graham扫描法


（1）选取最左下的点P0

（2）计算出每个点相对于P0的角度和距离来排序。

（3）设点数为n，将p[n-1]和p[0]入栈，判断点集合是否为一条直线（初始k=2表示当前凸包的大小）

（4）i从1到n-1遍历，对于p[k-1]，p[k-2]，p[i]若满足左转，将p[i]压入栈，否则就i--,k--

（5）k--，返回k表示凸包的点数



```c++
int Polygon::Graham(Polygon &con){
	int t=0,k=0;
	Point tmp; //先y最小再k最小 
	for(i=1;i<n;i++) if(p[i]<p[t]) t=i;
	swap(p[t],p[0]);
	for(int i=0;i<n;i++){
		tmp=p[i]-p[0];
		p[i].dis=tmp.Len2();
		p[i].angle=atan2(tmp.y,tmp.x);
	}
	sort(p,p+n,_cmp);
	con.p[k++]=p[n-1];
	con.p[k++]=p[0];
	if(Sig(p[1].angle-p[n-1].angle)==0)
		con.p[k++]=p[n-1];
	else{
		for(int i=1;i<n;i++){
			if(Sig(Cross(con.p[k-1],con.p[k-2],p[i]))>0)
				con.p[k++]=p[i];
			else{
				i--;
				k--;
			}
		}
	}
} 	return con.n=--k;
```

