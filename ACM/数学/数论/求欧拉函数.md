### 欧拉函数



##### 暴力

```c++
int Eular(int m){
	int ret=m;
	for(int i=2;i<m;i++){
		if(m%i==0) ret-=ret/i;
		while(m%i==0){
			m/=i;
		}
	}
	if(m>1) ret-=ret/m;
	return ret;
} 
```



##### 筛选法

```c++
void init(){ //筛选法打欧拉函数表 
	euler[1]=1;
	for(int i=2;i<maxn;i++) euler[i]=i;
	for(int i=2;i<maxn;i++)
		if(euler[i]==i)
			for(int j=i;j<maxn;j+=i)
				euler[j]=euler[j]/i*(i-1);
}
```



##### 直接求解欧拉函数

```c++
int eu(int n){  //直接求解欧拉函数 
        int res=n,a=n;  
        for(int i=2;i*i<=a;i++){
                if(a%i==0){  //分解质因数 
                        res=res/i*(i-1);
                        while(a%i==0) a/=i; //把质因数彻底分解 
                }
        }
        if(a>1) res=res/a*(a-1);
        return res;
}
```



##### 线性（重要）

```c++
void Get_phi(){
	cnt=0;
	memset(flag,1,sizeof(flag));
	phi[1]=1;
	for(int i=2;i<maxn;i++){
		if(flag[i]){
			p[cnt++]=i;
			phi[i]=i-1;
		}
		for(int j=0;j<cnt;j++){
			if(i*p[j]>maxn) break;
			flag[i*p[j]]=false;
			if(i%p[j]==0){
				phi[i*p[j]]=p[j]*phi[i];
				break;
			}else phi[i*p[j]]=(p[j]-1)*phi[i];
		}
	}
}	
```



需要注意的性质：

①phi(p)==p-1是因为素数p除了1以外的因子只有p，所以与p互质的个数是p-1个；

②$phi(p^k)==p^k-p^{k-1}==(p-1)*p^{k-1}$

