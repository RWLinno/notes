---
title : 第十六届东北地区大学生程序设计竞赛（正式赛）
date : 2022-5-30
tags : ACM,题解，练习记录
author : Linno


---



# 第十六届东北地区大学生程序设计竞赛（正式赛）

题目链接：https://ac.nowcoder.com/acm/contest/35146

补题进度：6/13



### [A-Encryption](https://ac.nowcoder.com/acm/contest/35146/A)



### [B-Capital Program](https://ac.nowcoder.com/acm/contest/35146/B)

拓扑排序,将叶子节点一个个抽离直到剩下k个点即可，答案就是那些抽离结点的最大步数。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define int long long
using namespace std;
const int N=2e5+7;
const int mod=1e9+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}
int n,k,deg[N],vis[N],idx=0,ans;
vector<int>G[N];
queue<int>q;

void Solve(){
	cin>>n>>k;
	for(int i=1,u,v;i<n;++i){
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
		++deg[u];++deg[v];
	}
	for(int i=1;i<=n;++i) if(deg[i]==1) vis[i]=1,q.push(i);
	while(q.size()){
		int fro=q.front();
		q.pop();
		++idx; //首都外面的点
		if(idx>n-k) break;
		ans=max(ans,vis[fro]);
		for(auto to:G[fro]){
			vis[to]=max(vis[to],vis[fro]+1);
			if(--deg[to]==1){
				q.push(to);
			}
		}
	}
	if(n==k) ans=0;
	cout<<ans<<"\n";
}

signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
//	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```





### [C-Segment Tree](https://ac.nowcoder.com/acm/contest/35146/C)



### [D-Game](https://ac.nowcoder.com/acm/contest/35146/D)

对一个区间的答案只要判断所有数出现次数，如果都是偶数个就算Bob赢。用莫队离线询问即可。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
//#define inf 0x3f3f3f3f
//#define int long long
using namespace std;
const int N=2e5+7;
const int mod=1e9+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}

int n,m,bk,a[N];
int L=1,R=0,nowans=0;
int cnt[N];
struct Q{int l,r,id,ans;}q[N];
bool cmp(Q a,Q b){
	if(a.l/bk!=b.l/bk) return a.l<b.l;
	else{ //奇偶性排序 
		if((a.l/bk)&1) return a.r<b.r;
		else return a.r>b.r;  
	}
}
bool cmpID(Q a,Q b){return a.id<b.id;}

inline void add(int x){
	++cnt[a[x]];
	if(cnt[a[x]]&1) ++nowans;
	else --nowans;
}

inline void del(int x){
	--cnt[a[x]];
	if(cnt[a[x]]&1) ++nowans;
	else --nowans;
}

void Solve(){
	scanf("%d%d",&n,&m);
	bk=sqrt(n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=m;++i){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].id=i;
	}
	sort(q+1,q+1+m,cmp);
	for(int i=1;i<=m;++i){
		while(L>q[i].l) add(--L);
		while(R<q[i].r) add(++R);
		while(L<q[i].l) del(L++);
		while(R>q[i].r) del(R--);
		q[i].ans=nowans;
	}
	sort(q+1,q+1+m,cmpID);
	for(int i=1;i<=m;++i){
		puts((q[i].ans)?"Alice":"Bob"); 
	}
}

signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
//	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```



### [E-Plus](https://ac.nowcoder.com/acm/contest/35146/E)

打表验证结论即可。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define int long long
using namespace std;
const int N=2e5+7;
const int mod=1e9+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}

inline int fpow(int a,int b){
	int res=1;
	while(b){
		if(b&1) res=res*a;
		a=a*a;
		b>>=1;
	}
	return res;
}

inline bool is_p(int x){
	if(x==1) return false;
	for(int i=2;i*i<=x;++i) if(x%i==0) return false;
	return true;
}

void Solve(){
	int n;
	cin>>n;
	/*
	for(int i=1;i<=100;++i){
		for(int j=i;j<=100;++j){
			if(is_p(i)&&is_p(j))
			if(is_p(fpow(i,j)+fpow(j,i))){
				cout<<i<<" "<<j<<" "<<fpow(i,j)+fpow(j,i)<<"\n";
			}
		}
	}*/
	if(n>=3){
		cout<<"1\n2 3\n";
	}else cout<<0<<"\n"; 
}

signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
//	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```





### [F-Tree Path](https://ac.nowcoder.com/acm/contest/35146/F)



### [G-Hot Water Pipe](https://ac.nowcoder.com/acm/contest/35146/G)



### [H-Digit String](https://ac.nowcoder.com/acm/contest/35146/H)



### [I-Generator](https://ac.nowcoder.com/acm/contest/35146/I)

$ans=1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n-1}=ln(n)+\gamma$，其中$\gamma\approx 0.5772156649$为欧拉常数，赛场上忘了这个数可以直接打1e9的表反向求。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define int long long
#define double long double
using namespace std;
const int N=2e5+7;
const int mod=1e9+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}
int n,mx=1e8;
void Solve(){
	cin>>n;
	double f,res=1.0;
	if(n<10000000){
		for(int i=2;i<=n;++i){
			f=1/(double)(i-1);
			res+=f;
	//		cout<<res<<"!!\n";
		}
	}
	else res+=(double)(log(n)+0.5772156649);
	printf("%.10Lf",res);
}

signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
//	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```



### [J-Papers](https://ac.nowcoder.com/acm/contest/35146/J)



### [K-Maze](https://ac.nowcoder.com/acm/contest/35146/K)

简单bfs,额外记录当前方向以及在这个方向走了多少格即可。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
//#define int long long
using namespace std;
const int N=107;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}
struct node{int x,y,stp,tot,d;};
int n,m,vis[N][N][5][2],ans;
char mp[N][N];
queue<node>q;
const int xx[]={-1,1,0,0},yy[]={0,0,-1,1};//上下左右 

void Solve(){
	cin>>n>>m;
	ans=inf; //初始化 
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) for(int d=0;d<4;++d) vis[i][j][d][0]=vis[i][j][d][1]=inf;
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) cin>>mp[i][j];
	q.push((node){1,1,0,0,5});
	while(q.size()){
		node fro=q.front();
		q.pop();
		if(fro.stp>m||fro.tot>=ans) continue;
		if(fro.stp>=vis[fro.x][fro.y][fro.d][0]&&fro.tot>=vis[fro.x][fro.y][fro.d][1]) continue;
		vis[fro.x][fro.y][fro.d][0]=min(fro.stp,vis[fro.x][fro.y][fro.d][0]);
		vis[fro.x][fro.y][fro.d][1]=min(fro.tot,vis[fro.x][fro.y][fro.d][1]);
		if(fro.x==n&&fro.y==n){
			ans=min(ans,fro.tot);
			continue; 
		}
		for(int i=0;i<4;++i){
			int nx=fro.x+xx[i],ny=fro.y+yy[i];
			if(nx<1||nx>n||ny<1||ny>n||mp[nx][ny]=='*') continue;
			q.push((node){nx,ny,(i==fro.d)?fro.stp+1:1,fro.tot+1,i});
		}
	}
	if(ans>=inf) cout<<"-1\n";
	else cout<<ans<<"\n";
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```



### [L-Polygon](https://ac.nowcoder.com/acm/contest/35146/L)

签到题。显然只要所有其他边加起来大于最大的边即可。

```cpp
//#pragma GCC optimize("Ofast", "inline", "-ffast-math")
//#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define int long long
using namespace std;
const int N=2e5+7;
const int mod=1e9+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
//void write(int x){if(x>9) write(x/10);putchar(x%10+'0');}

int n,a[N],sum=0;
void Solve(){
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		sum+=a[i];
	}
	sort(a+1,a+1+n);
	if(sum-a[n]<=a[n]){
		cout<<"NO\n";
	}else cout<<"YES\n";
}

signed main(){
//	ios::sync_with_stdio(0);
//	cin.tie(0);cout.tie(0);
//  freopen("in.cpp","r",stdin);
//  freopen("out.cpp","w",stdout);
	int T=1;
//	cin>>T;
//	clock_t start,finish;
//	start=clock();
	while(T--){
		Solve();
	}
//	finish=clock();
//	cerr<<((double)finish-start)/CLOCKS_PER_SEC<<endl;	return 0;
}

```



### [M-Spiral](https://ac.nowcoder.com/acm/contest/35146/M)