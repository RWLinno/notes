---
title :PAT-2021年冬季考试-甲级
date : 2021-12-19
tags : ACM,练习记录
author : Linno
---





最终成绩96

rank:34

感觉都是水题，我报来玩玩的。但最后一题有4分没拿到，好丢人（原本看完题以为一个小时可以AK的）希望有大佬可以帮我看看代码。我的代码可能有很多没有用到的东西，写得太丑了不要骂我~（owo）~



# T1

### 题面

给你m个网站以及n个新闻，每个网址报道的n个新闻都有一个舆论值，如果这个舆论值出现次数是网站中最多（可以多个）的，那么他最有可能是假新闻。现在定义如果某个新闻在每个网站上认为是假的次数最多，那么他就是假的。问假新闻是哪个。

### 思路

我们首先对每个网站处理最多出现的值，然后使该网站上最有可能是假新闻的计数+1，跑完所以网站后取总的权值最大的那个下标即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N=1e4+7;

int n,m,ans[N],mp[105][N];
vector<int>vt[105];
map<int,int>cnt[105];

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n;j++){
			cin>>mp[i][j];
			cnt[i][mp[i][j]]++;
		}
		int mx=inf;
		for(int j=1;j<=n;j++){
			if(cnt[i][mp[i][j]]<mx){
				vt[i].clear();
				vt[i].push_back(j);
				mx=cnt[i][mp[i][j]];
			}else if(cnt[i][mp[i][j]]==mx) vt[i].push_back(j);
		}
	}
	for(int i=1;i<=m;i++){
		for(int j=0;j<vt[i].size();j++){
			ans[vt[i][j]]++;
		}
	}
	int res=1;
	for(int i=1;i<=n;i++) if(ans[i]>ans[res]) res=i;
	cout<<res<<"\n";
	return 0;
}
```



# T2

### 题面

给你每个节点后继对应的下标，求遍历顺序，并输出1~n每个节点的遍历时间。

### 思路

找到头节点（没有前驱）然后一直跑到尾节点（没有后继），然后记录rank即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+7;

int n,x,nxt[N],pre[N],rnk[N];

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){ 
		cin>>x;
		if(x!=-1){
			nxt[i]=x+1;
			pre[x+1]=i;
		}else nxt[i]=-1;
	}
	for(int i=1;i<=n;i++){
		if(!pre[i]){
			int idx=0;
			while(1){
				rnk[i]=++idx;
				if(nxt[i]==-1) break; 
				i=nxt[i];
			}
			break;
		}
	}
	for(int i=1;i<=n;i++){
		cout<<rnk[i];
		if(i==n) cout<<"\n";
		else cout<<" ";
	} 
	return 0;
}
```



# T3

### 题面

给你一棵树和q个询问，每次询问x的子树大小。

### 思路

是的跑一遍dfs就行了……

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+7;

vector<int>G[N];
int n,q,u;
int dep[N],fa[N],sz[N],son[N];
void dfs1(int x){
	sz[x]=1;
	for(int i=0;i<G[x].size();i++){
		int to=G[x][i];
		if(to==fa[x]) continue;
		fa[to]=x;
		dep[to]=dep[x]+1;
		dfs1(to);
		sz[x]+=sz[to];
		if(sz[son[x]]<sz[to]) son[x]=to;
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=2;i<=n;i++){
		cin>>u;
		G[u].push_back(i);
		G[i].push_back(u);
	}
	dfs1(1);
	cin>>q;
	for(int i=1,x;i<=q;i++){
		cin>>x;
		cout<<sz[x]<<"\n";
	}
	return 0;
}
```



# T4

### 题面

给一个图，每个节点都有快递配送的时限，如果超过时限就要扣钱，只要走到了就有钱收。快递小哥从0号点出发，给你k种方案，问能跑完所有节点并且收钱最多的基础上用时最少的方案的编号。

### 思路

这题给了3秒，floyd处理一下全源最短路信息。然后对每个方案都判断有没有跑完所有节点，然后再去逐个点地去跑，拿到这个方案的收益和时间，然后按要求转化答案即可。

细节：

①时间都在当天，但是配送玩的时间有可能是次日。

②最后可能亏钱，所有要初始化成-inf。

### 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N=1007;

int n,m,u,v,k,ansh,ansm;
int path[N][N],vis[105][N],ti[N];
double mp[N][N],sc[N],w;
int hour[N],minu[N],arr[N],anst=inf;
double anssc=-inf,sum=0;
//最后挣的钱有可能是负数 
struct X{
	double tim,y,p;
}s[N];

void solve(int idx){
	int now=0;
	sc[idx]=sum;
	for(int i=1;i<=n;i++){
		int to=path[idx][i];
		ti[idx]+=mp[now][to];
		arr[to]=ti[idx];
		now=to;
	}
	for(int i=1;i<=n;i++) if(arr[i]>s[i].tim) sc[idx]-=s[i].p; 
	ti[idx]+=mp[now][0];
}

signed main(){
	scanf("%d%d",&n,&m);
	scanf("%d:%d",&hour[0],&minu[0]);
	//memset(mp,127/3,sizeof(mp));
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			mp[i][j]=inf;
		}
	}
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=n;i++) mp[i][i]=0;
	for(int i=1;i<=n;i++){
		scanf("%d:%d %lf%lf",&hour[i],&minu[i],&s[i].y,&s[i].p);
		sum+=s[i].y;
		s[i].tim=(hour[i]-hour[0])*60+(minu[i]-minu[0]);
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d%lf",&u,&v,&w);
		mp[u][v]=mp[v][u]=min(w,mp[u][v]);
	}
	for(int k=0;k<=n;k++){
		for(int i=0;i<=n;i++){
			for(int j=0;j<=n;j++){
				if(mp[i][j]>mp[i][k]+mp[k][j]){
					mp[i][j]=mp[i][k]+mp[k][j];
				}
			}
		}
	}
	scanf("%d",&k);
	for(int i=1;i<=k;i++){
		int flag=0;
		for(int j=1;j<=n;j++){
			scanf("%d",&path[i][j]);
			vis[i][path[i][j]]=1;
		}
		for(int j=1;j<=n;j++){
			if(!vis[i][j]) flag=1; //如果某个点没有送到，不用考虑
		}
		if(flag) continue;
		solve(i); //计算该方案的得分与时间
		if(sc[i]>anssc){
			anssc=sc[i];
			anst=ti[i];
		}else if(sc[i]==anssc&&ti[i]<anst){
			anssc=sc[i];
			anst=ti[i];
		}
	}
	ansh=hour[0]+anst/60;
	anst%=60;
	ansm=minu[0]+anst;
	if(ansm>=60){
		ansh++;
		ansm-=60;
	}
	if(ansh>=24) ansh-=24;
	printf("%lf %02d:%02d\n",anssc,ansh,ansm);
	return 0;
}
```

