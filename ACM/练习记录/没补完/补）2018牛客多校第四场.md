---
title : 2018牛客多校第四场
date : 2021-10-4
tags : ACM,练习记录
author : Linno

---



题目链接：https://ac.nowcoder.com/acm/contest/20325#question

进度：4/10



# A-Ternary String

### 题意

给一个012串，每秒2会生1，1会生0，并删掉最前面的数，求要多少次可以删完。

### 思路

首先肯定是可以删完的，-1的情况肯定没有。递推式：

$ans[i]=\begin{cases}ans[i]=ans[i-1]+1,str[i]=='0'\\ans[i]=2*(ans[i-1]+1),str[i]=='1'\\ans[i]=3*(2^{ans+1}-1),str[i]=='2'\end{cases}$

但是ans+1作为指数太大，而且底数和模数不一定互质，因此需要用到扩展欧拉定理。给出模板：
$$
a^c\equiv \begin{cases}
a^{c\mod \phi(m)} ,gcd(a,m)\neq 1\\
a^c,gcd(a,m)\neq 1 \&\&c<\phi(m)\\
a^{c \mod\phi(m) +\phi(m)},gcd(a,m)\neq 1\&\&c\ge\phi(m)
\end{cases}
$$

### 代码

```C++
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int phi[] = {1000000007, 1000000006, 500000002, 243900800, 79872000,
                   19660800,   5242880,    2097152,   1048576,   524288,
                   262144,     131072,     65536,     32768,     16384,
                   8192,       4096,       2048,      1024,      512,
                   256,        128,        64,        32,        16,
                   8,          4,          2,         1};

int qpow(int a,int b,int m){
   	int res=1;
   	while(b){
		if(b&1) res=res*a%m;
		a=a*a%m;
		b>>=1;
	}
	return res%m;
}

int gcd(int a,int b){return b?gcd(b,a%b):a;}

string str;

int dfs(int pos,int m){
	if(pos==-1||phi[m]==1) return 0;
	if(str[pos]=='0'){
		return (dfs(pos-1,m)+1)%phi[m];
	}else if(str[pos]=='1'){
		return ((dfs(pos-1,m)+1)<<1)%phi[m];
	}else return 3*(qpow(2,dfs(pos-1,m+1)+1,phi[m])-1+phi[m])%phi[m];
}

signed main(){
    int t;
   	cin>>t;
    while(t--){
        cin>>str;
		int n=str.length(); 
        cout<<dfs(n-1,0)<<"\n";
    }
    return 0;
}
```





# D-Another Distinct Values

### 题意

构造一个n阶方阵，每个位置填上1，0，-1之中的一个，使得每一行以及每一列的和不重复。

### 思路

手推后容易发现n为奇数时都无解，n为偶数时令方阵+

### 代码

```C++
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;

int t,n,mp[205][205];

signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		//mp.clear();
		if(n&1){
			puts("impossible");
		}else{
			memset(mp,0,sizeof(mp));
			puts("possible");
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					if(i+j==n+1){
						if(i*2<=n) mp[i][j]=0;
						else mp[i][j]=1; 
					}else if(i+j<n+1) mp[i][j]=1;
					else mp[i][j]=-1;
				}
			}
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					cout<<mp[i][j]<<" ";
				}
				cout<<"\n";
			}
		}
	} 
	return 0;
}
```



# F-Beautiful Garden

### 题意

在n×m的地图中建p×q的水池（填白），使得地图对称。求满足的<p,q>对数。p,q严格小于n,m。

### 思路

二维前缀和可求出任意矩形中不对称字符的对数。那么我们只需要沿着对称轴枚举p,q，如果水池中的不对称字符对和地图的不对称字符对相等，那么答案++。

### 代码

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
typedef long long ll;
const int maxn=2005;

int t,n,m,p,q;
int sum[maxn][maxn],flag;
char mp[maxn][maxn];

int S(int x1,int y1,int x2,int y2){
	return sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1];
}

signed main(){
	cin>>t;
	while(t--){
		memset(sum,0,sizeof(sum));
		cin>>n>>m;
		int ans=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>mp[i][j];
			}
		}
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				if(mp[i][j]!=mp[n-i+1][m-j+1]){
					flag=1;
				}else flag=0;
				sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+flag;
			}
		}
		for(int p=2;p<=(n+1)/2;p++){
			for(int q=2;q<=(m+1)/2;q++){
				if(S(p,q,n-p+1,m-q+1)==sum[n][m]) ans++;
			}
		}
		cout<<ans<<"\n";
	}
	return 0;
}
```



# G-Maximum Mode

### 题目

问能否删除m个数，使得数列中只有一个众数且该总数值最大，如果不能则输出-1，否则输出总数的最大值。

### 思路

首先如果小于m次的删除能达成目的，那么m次也可以达成，无需特判。先把每个数的次数记录下来，然后弄个二元组，以次数为第一关键字排序，那么我们对于左边的节点我们无需删数，对右边的节点我们删成(该节点次数-1)*后面节点数即可。对于前面有一样次数的节点，额外再删一个。

### 代码

```C++
#include <bits/stdc++.h>
#define int long long
#define fi first 
#define se second 
using namespace std;

typedef pair<int,int>P;
int t,n,m;
unordered_map<int, int> cnt,vis;
vector<P>L;

signed main() {
//	freopen("in.cpp","r",stdin); 
    cin>>t;
	while(t--){
	    cin>>n>>m;
	    cnt.clear();vis.clear(); //清空 
		L.clear();
		for(int i=1,x;i<=n;i++){
	    	cin>>x;
	    	cnt[x]++; //记录个数 
		}
		for(auto q:cnt){
			L.push_back({q.se,q.fi});
		}
		sort(L.begin(),L.end(),less<P>()); //数量少的排在前面 
		int suml=0,count=L.size()-1,ans=-1;
		for(auto p:L){
			int need=(n-p.fi-suml)-count*(p.fi-1)+vis[p.fi];
			if(need<=m){
				ans=max(ans,p.se);
			}
			count--;
			suml+=p.fi;
			vis[p.fi]++;
		}
		cout<<ans<<"\n";
 	}
    return 0;
}
```

