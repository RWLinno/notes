---
title : 「SDOI2014」旅行
tags : ACM,数据结构
date : 2022-1-28
author : Linno
---

### 题目描述

S 国有 个城市，编号从 到 。城市间用 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。为了方便，我们用不同的正整数代表各种宗教，S 国境内总共有 种不同的宗教。

S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国政府为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。

在 S 国的历史上常会发生以下几种事件：

1. `CC x c`：城市 的居民全体改信了 教；
2. `CW x w`：城市 的评级调整为 ；
3. `QS x y`：一位旅行者从城市 出发，到城市 ，并记下了途中留宿过的城市的评级总和；
4. `QM x y`：一位旅行者从城市 出发，到城市 ，并记下了途中留宿过的城市的评级最大值。

由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。
为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。



### 思路

维护一棵树两点之间各个颜色的区域数据，树链剖分+主席树。

动态开点可以避免爆空间的问题，每一棵树维护一种颜色。



### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+7;

//int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int n,m,c[N],w[N],u,v,root;
string op;
vector<int>G[N];
int sz[N],dep[N],son[N],fa[N],dfn[N],idfn[N],bel[N],idx;

void dfs1(int x){
	sz[x]=1;
	for(int i=0;i<G[x].size();i++){
		int to=G[x][i];
		if(to==fa[x]) continue;
		dep[to]=dep[x]+1;
		fa[to]=x;
		dfs1(to);
		sz[x]+=sz[to];
		if(sz[son[x]]<sz[to]) son[x]=to;
	}
}

void dfs2(int x,int tp){
	dfn[x]=++idx;
	idfn[idx]=x;
	bel[x]=tp;
	if(son[x]) dfs2(son[x],tp);
	for(int i=0;i<G[x].size();i++){
		int to=G[x][i];
		if(to==fa[x]||to==son[x]) continue;
		dfs2(to,to); 
	}
}

#define ls tr[p].l
#define rs tr[p].r
#define mid ((l+r)>>1)

struct node{
	int l,r,w,mx;
}tr[N*20];
int rt[N],cnt;

void pushup(int p){
	tr[p].w=tr[ls].w+tr[rs].w;
	tr[p].mx=max(tr[ls].mx,tr[rs].mx);
}

void update(int &p,int l,int r,int pos,int val){
	if(!p) p=++cnt;
	if(l==r){
		tr[p].w+=val;
		tr[p].mx=tr[p].w;
		return;
	}
	if(pos<=mid) update(ls,l,mid,pos,val);
	else update(rs,mid+1,r,pos,val);
	pushup(p);
}

int query(int p,int l,int r,int ql,int qr,int o){ //线段树查询 
	if(ql<=l&&r<=qr) return o?tr[p].mx:tr[p].w;
	int res=0;
	if(ql<=mid&&ls) res=query(ls,l,mid,ql,qr,o);
	if(qr>mid&&rs){
		if(o) res=max(res,query(rs,mid+1,r,ql,qr,o));
		else res+=query(rs,mid+1,r,ql,qr,o);
	}
	return res;
}

int query(int x,int y,int o){//树链剖分查询 
	int res=0,root=rt[c[x]];
	while(bel[x]!=bel[y]){
		if(dep[bel[x]]<dep[bel[y]]) swap(x,y);
		int tmp=query(root,1,n,dfn[bel[x]],dfn[x],o);
		if(o) res=max(res,tmp);
		else res+=tmp;
		x=fa[bel[x]];
	}
	if(dep[x]>dep[y]) swap(x,y);
	int tmp=query(root,1,n,dfn[x],dfn[y],o);
	if(o) res=max(res,tmp);
	else res+=tmp;
	return res; 
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>w[i]>>c[i];
	for(int i=1;i<n;i++){
		cin>>u>>v;
		G[u].push_back(v);
		G[v].push_back(u);
	} 
	dep[1]=fa[1]=1;
	dfs1(1);
	dfs2(1,1);
	for(int i=1;i<=n;i++) update(rt[c[i]],1,n,dfn[i],w[i]);
	for(int i=1;i<=m;i++){
		cin>>op>>u>>v;
		if(op=="CC"){
			update(rt[c[u]],1,n,dfn[u],-w[u]);
			update(rt[v],1,n,dfn[u],w[u]);
			c[u]=v;
		}
		if(op=="CW"){
			update(rt[c[u]],1,n,dfn[u],v-w[u]);
			w[u]=v;
		}
		if(op=="QS") cout<<query(u,v,0)<<"\n"; 
		if(op=="QM") cout<<query(u,v,1)<<"\n";
	}
	return 0;
}

```





### 参考

https://loj.ac/s/1351442