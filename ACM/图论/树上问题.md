### 求树的直径

做法1：两遍dfs

做法2：树形dp





### 最近公共祖先（LCA）

倍增算法 O(nlogn)

```C++
void dfs(int u,int fa){  //dfs求深度 
	dep[u]=dep[fa]+1;
	p[u][0]=fa;
	for(int i=1;(1<<i)<=dep[u];i++)
		p[u][i]=p[p[u][i-1]][i-1];
	for(int i=head[u];i;i=edge[i].next){
		int to=edge[i].to;
		if(to!=fa) dfs(to,u);
	} 
}

int lca(int x,int y){
	if(dep[x]>dep[y]) swap(x,y);
	for(int i=20;i>=0;i--){
		if(dep[x]<=dep[y]-(1<<i)) y=p[y][i]; 
	}//统一深度
	if(x==y) return x;
	for(int i=20;i>=0;i--){
		if(p[x][i]==p[y][i]) continue;
		else x=p[x][i],y=p[y][i];
	} 
	return p[x][0];
}
```



Tarjan算法 O(n+m)





### 求树的重心

**以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。**

在 DFS 中计算每个子树的大小，记录“向下”的子树的最大大小，利用总点数 - 当前子树（这里的子树指有根树的子树）的大小得到“向上”的子树的大小，然后就可以依据定义找到重心了。

```C++
// 这份代码默认节点编号从 1 开始，即 i ∈ [1,n]
int size[MAXN],  // 这个节点的“大小”（所有子树上节点数 + 该节点）
    weight[MAXN],  // 这个节点的“重量”
    centroid[2];   // 用于记录树的重心（存的是节点编号）
void GetCentroid(int cur, int fa) {  // cur 表示当前节点 (current)
  size[cur] = 1;
  weight[cur] = 0;
  for (int i = head[cur]; i != -1; i = e[i].nxt) {
    if (e[i].to != fa) {  // e[i].to 表示这条有向边所通向的节点。
      GetCentroid(e[i].to, cur);
      size[cur] += size[e[i].to];
      weight[cur] = max(weight[cur], size[e[i].to]);
    }
  }
  weight[cur] = max(weight[cur], n - size[cur]);
  if (weight[cur] <= n / 2) {  // 依照树的重心的定义统计
    centroid[centroid[0] != 0] = cur;
  }
}
```



