### 求两个多项式的卷积

##### FFT

```cpp
#include<bits/stdc++.h>
#define int ll
using namespace std;
typedef long long ll;
typedef complex<double> cp;
const double pi=acos(-1);
const int maxn=1e7+7;

cp a[maxn],b[maxn];

inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=f*-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}

/*
struct complex{
	double x,y;
	complex (double xx=0,double yy=0){x=xx,y=yy;}
	complex operator + (complex a,complex b){return complex(a.x+b.x,a.y+b.y);}
	complex operator - (complex a,complex b){return complex(a.x-b.x,a.y-b.y);}
	complex operator * (complex a,complex b){return complex(a.x*b.x-a.y*b.y,a.y*b.y+a.y*b.x);}
};
*/

int n,m,limit=1;
int l,r[maxn];

void fft(cp *A,int type){
	for(int i=0;i<limit;i++){
		if(i<r[i]) swap(A[i],A[r[i]]);
	}
	for(int mid=1;mid<limit;mid<<=1){
		cp wn(cos(pi/mid),type*sin(pi/mid));
		for(int R=mid<<1,j=0;j<limit;j+=R){
			cp w(1,0);
			for(int k=0;k<mid;k++,w=w*wn){
				cp x=A[j+k],y=w*A[j+mid+k];
				A[j+k]=x+y;
				A[j+mid+k]=x-y;
			} 
		}
	}
}

signed main(){
	n=read();m=read();
	for(int i=0;i<=n;i++) a[i].real()=(double)read();
	for(int i=0;i<=m;i++) b[i].real()=(double)read();
	while(limit<=n+m) limit<<=1,l++;
	for(int i=0;i<limit;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	fft(a,1);
	fft(b,1);
	for(int i=0;i<=limit;i++) a[i]=a[i]*b[i];
	fft(a,-1);
	for(int i=0;i<=n+m;i++)
		printf("%d ",(int)(a[i].real()/limit+0.5));
	return 0;
}
```



##### NTT

```cpp
#include<bits/stdc++.h>
#define swap(x,y) x^=y,y^=x,x^=y
#define int long long 
using namespace std;
const int MAXN=3*1e6+10,P=998244353,G=3,Gi=332748118; //G为P的原根 
char buf[1<<21],*p1=buf,*p2=buf;
int read(){	int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-') f=f*-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int N,M,limit=1,L,r[MAXN];
int a[MAXN],b[MAXN];

inline int fastpow(int a,int k) {
	int base=1;
	while(k){
		if(k&1) base=(base*a)%P;
		a=(a*a)%P;
		k>>=1;
	}
	return base%P;
}

inline void NTT(int *A, int type) {
	for(int i=0;i<limit;i++) 
		if(i<r[i]) swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1) {	
		int Wn=fastpow(type==1?G:Gi,(P-1)/(mid<<1));
		for(int j=0;j<limit;j+=(mid<<1)) {
			int w=1;
			for(int k=0;k<mid;k++,w=(w*Wn)%P){
				 int x=A[j+k],y=w*A[j+k+mid]%P;
				 A[j+k]=(x+y)%P,
				 A[j+k+mid]=(x-y+P)%P;
			}
		}
	}
}
signed main(){
  //  freopen("F.in","r",stdin);
   // freopen("F.out","w",stdout);
	N=read();M=read();
	for(int i=0;i<=N;i++) a[i]=(read()+P)%P;
	for(int i=0;i<=M;i++) b[i]=(read()+P)%P;
	while(limit<=N+M) limit<<=1,L++;
	for(int i=0;i<limit;i++) r[i]=(r[i>>1]>>1)|((i&1)<<(L-1));	
	NTT(a,1);NTT(b,1);	
	for(int i=0;i<limit;i++) a[i]=(a[i]*b[i])%P;
	NTT(a,-1);	
	int inv=fastpow(limit,P-2);
	for(int i = 0; i <= N + M; i++)	printf("%d ",(a[i]*inv)%P);
	return 0;
}
```



